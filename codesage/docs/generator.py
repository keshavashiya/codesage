"""Documentation generator for CodeSage."""

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List, Optional, Set

from codesage.memory.memory_manager import MemoryManager
from codesage.storage.database import Database
from codesage.utils.config import Config


def _pluralize(word: str, count: int) -> str:
    """Pluralize a word based on count."""
    if count == 1:
        return word
    # Handle irregular plurals
    if word == "class":
        return "classes"
    if word.endswith("s") or word.endswith("x") or word.endswith("ch"):
        return f"{word}es"
    return f"{word}s"


class DocumentationGenerator:
    """Generate project documentation from indexed context."""

    def __init__(self, config: Config) -> None:
        self.config = config
        self._db = Database(config.storage.db_path)
        self._memory = None
        if config.memory.enabled:
            self._memory = MemoryManager(
                global_dir=config.memory.global_dir,
            )

    def generate(self, sections: Optional[List[str]] = None) -> str:
        if sections is None:
            sections = [
                "overview",
                "architecture",
                "modules",
                "patterns",
                "key_components",
            ]

        parts: List[str] = [f"# {self.config.project_name} Documentation", ""]

        stats = self._db.get_stats()
        lang_stats = self._db.get_language_stats()

        if "overview" in sections:
            parts.extend(self._generate_overview(stats, lang_stats))

        if "architecture" in sections:
            parts.extend(self._generate_architecture(lang_stats))

        if "modules" in sections:
            parts.extend(self._generate_modules())

        if "patterns" in sections:
            parts.extend(self._generate_patterns())

        if "key_components" in sections:
            parts.extend(self._generate_key_components())

        # Add generation footer
        parts.extend([
            "---",
            "",
            f"*Documentation generated by CodeSage from {stats.get('files', 0)} indexed files.*",
        ])

        return "\n".join(parts).strip() + "\n"

    def _generate_overview(
        self,
        stats: Dict[str, Any],
        lang_stats: Dict[str, Dict[str, int]],
    ) -> List[str]:
        """Generate project overview section."""
        parts = [
            "## Overview",
            "",
            f"**Project:** {self.config.project_name}",
            "",
        ]

        # Language breakdown
        if lang_stats:
            parts.append("### Languages")
            parts.append("")
            parts.append("| Language | Files | Elements |")
            parts.append("|----------|-------|----------|")
            for lang, counts in sorted(
                lang_stats.items(),
                key=lambda x: x[1].get("elements", 0),
                reverse=True,
            ):
                parts.append(
                    f"| {lang.capitalize()} | {counts.get('files', 0)} | {counts.get('elements', 0)} |"
                )
            parts.append("")
        else:
            parts.append(f"**Languages:** {', '.join(self.config.languages)}")
            parts.append("")

        parts.extend([
            f"**Total Files:** {stats.get('files', 0)}",
            f"**Total Elements:** {stats.get('elements', 0)}",
            "",
        ])

        return parts

    def _generate_architecture(
        self,
        lang_stats: Dict[str, Dict[str, int]],
    ) -> List[str]:
        """Generate architecture diagram section."""
        parts = [
            "## Architecture",
            "",
        ]

        # Discover module structure from indexed files
        modules = self._discover_modules()

        # Filter out tests for architecture diagram
        src_modules = {m for m in modules if not m.startswith("test")}

        if src_modules:
            parts.append("```mermaid")
            parts.append("graph TD")
            parts.append(f"    Root[{self.config.project_name}]")

            # Add submodules
            for module in sorted(src_modules):
                # Clean module name for Mermaid (no special chars)
                safe_name = module.replace("-", "_").replace(".", "_")
                parts.append(f"    Root --> {safe_name}[{module}]")

            parts.append("```")
            parts.append("")
        else:
            parts.append("```mermaid")
            parts.append("graph TD")
            parts.append(f"    Project[{self.config.project_name}]")
            parts.append("```")
            parts.append("")
            parts.append("*Note: Index the project to populate architecture details.*")
            parts.append("")

        return parts

    def _generate_modules(self) -> List[str]:
        """Generate module descriptions based on indexed elements."""
        parts = ["## Modules", ""]

        modules = self._discover_modules_with_stats()

        if not modules:
            parts.append("*No module data available. Run `codesage index` first.*")
            parts.append("")
            return parts

        # Separate source modules from test modules
        src_modules = {k: v for k, v in modules.items() if not k.startswith("test")}
        test_modules = {k: v for k, v in modules.items() if k.startswith("test")}

        # Show source modules first
        for module_name, info in sorted(
            src_modules.items(),
            key=lambda x: x[1].get("elements", 0),
            reverse=True,
        )[:10]:
            parts.extend(self._format_module_section(module_name, info))

        # Show test modules summary
        if test_modules:
            total_test_elements = sum(m.get("elements", 0) for m in test_modules.values())
            total_test_classes = sum(
                m.get("types", {}).get("class", 0) for m in test_modules.values()
            )
            parts.append("### tests")
            parts.append("")
            parts.append(
                f"Contains {total_test_elements} test elements across "
                f"{total_test_classes} test {_pluralize('class', total_test_classes)}."
            )
            parts.append("")

        return parts

    def _format_module_section(
        self,
        module_name: str,
        info: Dict[str, Any],
    ) -> List[str]:
        """Format a single module section."""
        parts = [f"### {module_name}", ""]

        # Count by element type with proper pluralization
        type_counts = info.get("types", {})
        if type_counts:
            counts_parts = []
            for etype, count in sorted(type_counts.items()):
                counts_parts.append(f"{count} {_pluralize(etype, count)}")
            counts_str = ", ".join(counts_parts)
            parts.append(f"Contains {counts_str}.")
        else:
            parts.append(f"Contains {info.get('elements', 0)} elements.")

        # List key classes/functions (non-test)
        key_items = info.get("key_items", [])
        # Filter out test classes
        non_test_items = [
            item for item in key_items
            if not item["name"].startswith("Test")
        ]

        if non_test_items:
            parts.append("")
            parts.append("**Key components:**")
            for item in non_test_items[:5]:
                parts.append(f"- `{item['name']}` ({item['type']})")

        parts.append("")
        return parts

    def _generate_patterns(self) -> List[str]:
        """Generate coding patterns section."""
        parts = ["## Coding Patterns", ""]

        if not self._memory:
            parts.append("*Pattern detection requires memory features to be enabled.*")
            parts.append("")
            return parts

        try:
            patterns = self._memory.preference_store.get_patterns(limit=10)
        except Exception:
            patterns = []

        if patterns:
            parts.append("The following patterns were detected in this codebase:")
            parts.append("")

            for p in patterns:
                confidence = p.confidence_score
                confidence_label = (
                    "high" if confidence >= 0.8
                    else "medium" if confidence >= 0.5
                    else "low"
                )
                parts.append(
                    f"- **{p.name}** — confidence: {confidence:.0%} ({confidence_label})"
                )

                if hasattr(p, "description") and p.description:
                    parts.append(f"  - {p.description}")

            parts.append("")
        else:
            parts.append("*No patterns learned yet. Use the tool more to accumulate data.*")
            parts.append("")

        return parts

    def _generate_key_components(self) -> List[str]:
        """Generate key components section with top classes and functions."""
        parts = ["## Key Components", ""]

        # Get all elements and find the most significant ones
        try:
            elements = list(self._db.get_all_elements(batch_size=500))
        except Exception:
            elements = []

        if not elements:
            parts.append("*No elements indexed. Run `codesage index` first.*")
            parts.append("")
            return parts

        # Filter out test files for key components
        src_elements = [
            e for e in elements
            if "test" not in str(e.file).lower()
        ]

        if not src_elements:
            src_elements = elements  # Fall back to all if no non-test files

        # Group by type
        classes = [e for e in src_elements if e.type == "class"]
        functions = [e for e in src_elements if e.type == "function"]

        if classes:
            parts.append("### Classes")
            parts.append("")

            # Sort by code length (proxy for significance), filter out test classes
            non_test_classes = [
                c for c in classes
                if c.name and not c.name.startswith("Test")
            ]
            top_classes = sorted(
                non_test_classes, key=lambda e: len(e.code), reverse=True
            )[:10]

            for cls in top_classes:
                file_rel = self._relative_path(cls.file)
                doc_excerpt = ""
                if cls.docstring:
                    # First line of docstring
                    first_line = cls.docstring.strip().split("\n")[0]
                    if len(first_line) > 80:
                        first_line = first_line[:77] + "..."
                    doc_excerpt = f" — {first_line}"

                parts.append(f"- **{cls.name}** (`{file_rel}`){doc_excerpt}")

            parts.append("")

        if functions:
            parts.append("### Functions")
            parts.append("")

            # Exclude private/dunder/test functions, sort by code length
            public_funcs = [
                f for f in functions
                if f.name
                and not f.name.startswith("_")
                and not f.name.startswith("test")
            ]
            top_funcs = sorted(
                public_funcs, key=lambda e: len(e.code), reverse=True
            )[:10]

            for func in top_funcs:
                file_rel = self._relative_path(func.file)
                doc_excerpt = ""
                if func.docstring:
                    first_line = func.docstring.strip().split("\n")[0]
                    if len(first_line) > 80:
                        first_line = first_line[:77] + "..."
                    doc_excerpt = f" — {first_line}"

                parts.append(f"- **{func.name}** (`{file_rel}`){doc_excerpt}")

            parts.append("")

        return parts

    def _discover_modules(self) -> Set[str]:
        """Discover top-level modules from indexed files."""
        modules: Set[str] = set()

        try:
            for element in self._db.get_all_elements(batch_size=500):
                file_path = Path(element.file)
                parts = file_path.parts

                # Find source package in path
                # Look for project_name/submodule or just the package structure
                for i, part in enumerate(parts):
                    if part == self.config.project_name:
                        # Check if this is a directory (has more parts)
                        if i + 1 < len(parts):
                            next_part = parts[i + 1]

                            # Skip hidden/private dirs
                            if next_part.startswith("_") or next_part.startswith("."):
                                continue

                            # If it's a .py file at project root, skip
                            if next_part.endswith(".py"):
                                continue

                            # This is a submodule
                            modules.add(next_part)

                            # Also check for second-level submodules (e.g., codesage/cli)
                            if i + 2 < len(parts):
                                sub_part = parts[i + 2]
                                if (
                                    not sub_part.startswith("_")
                                    and not sub_part.startswith(".")
                                    and not sub_part.endswith(".py")
                                ):
                                    # Record as parent/child for richer view
                                    modules.add(next_part)
                        break
        except Exception:
            pass

        return modules

    def _discover_modules_with_stats(self) -> Dict[str, Dict[str, Any]]:
        """Discover modules with element counts and key items."""
        modules: Dict[str, Dict[str, Any]] = {}

        try:
            for element in self._db.get_all_elements(batch_size=500):
                file_path = Path(element.file)
                parts = file_path.parts

                # Find module name - look for first non-project directory
                module_name = None
                for i, part in enumerate(parts):
                    if part == self.config.project_name:
                        if i + 1 < len(parts):
                            next_part = parts[i + 1]
                            if next_part.startswith("_") or next_part.startswith("."):
                                continue
                            if next_part.endswith(".py"):
                                module_name = next_part[:-3]
                            else:
                                module_name = next_part
                        break

                if not module_name:
                    continue

                if module_name not in modules:
                    modules[module_name] = {
                        "elements": 0,
                        "types": {},
                        "key_items": [],
                    }

                modules[module_name]["elements"] += 1

                # Count by type
                etype = element.type
                modules[module_name]["types"][etype] = (
                    modules[module_name]["types"].get(etype, 0) + 1
                )

                # Track key items (classes and public functions)
                if element.type == "class" or (
                    element.type == "function"
                    and element.name
                    and not element.name.startswith("_")
                ):
                    modules[module_name]["key_items"].append({
                        "name": element.name,
                        "type": element.type,
                    })

        except Exception:
            pass

        return modules

    def _relative_path(self, file_path: Path) -> str:
        """Convert absolute path to relative path from project root."""
        try:
            return str(file_path.relative_to(self.config.project_path))
        except ValueError:
            # If not relative, return just the filename
            return file_path.name

    def write(self, output_dir: Path, sections: Optional[List[str]] = None) -> Path:
        output_dir.mkdir(parents=True, exist_ok=True)
        content = self.generate(sections=sections)
        out_file = output_dir / "README.md"
        out_file.write_text(content, encoding="utf-8")
        return out_file
